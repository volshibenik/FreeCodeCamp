<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Simon Game</title>
	<link rel="stylesheet" href="style.css">
</head>
<body>
	<div class="cube"></div>
	<div class="cube"></div>
	<div class="cube"></div>
	<div class="cube"></div>
	<script>
		const cubes = document.getElementsByClassName('cube');
		arr = [0,2,1,3];
		
		function simon_sequence(array) {
			for(var i = 0; i < array.length; i++) {
				
				
				
			}
		}
		
		function play(num) {
			cubes[num].innerHTML = 'lll';
			console.log('as');
		}
		simon_sequence(arr);
		
		window.addEventListener('keydown', function(e){
			console.log(e.keyCode);
		})
		
		//both below work
		
		/////
		function doScaledTimeout(i) {
			setTimeout(function() {
				play(arr[i]);
				console.log(i);
			}, i * 2000);
		}
		
		for (var i = 0; i <= 3; ++i)
			doScaledTimeout(i);
		/////
		
		
		
	/*	(function fn(n) {
			console.log(n);
			if (n < arr.length) setTimeout(function() {
				play(arr[n]);
				fn(++n);
			}, 1000);
		}(0));
		*/
		
		
		//https://stackoverflow.com/questions/24293376/javascript-for-loop-with-timeout
		/*
		You can approach your situation in two ways.

You can immedately schedule a whole bunch of setTimeout() calls with varying times so they will execute at the desired times in the future (other answers here illustrate how to do that).
You can execute the first iteration, schedule the next iteration and have the execution of the next iteration schedule the one after that until you've finished the desired number of iterations. This is ultimately a bit more scalable than setting a lot of setTimeout() call and gives you more branching/logic freedom because you are in control of what happens next after each iteration.
This second option using a more general purpose utility function would look like this:

// utility function to call a callback numTimes, 
// separated by delay milliseconds
function runIteration(fn, numTimes, delay) {
    var cnt = 0;
    function next() {
        // call the callback and stop iterating if it returns false
        if (fn(cnt) === false) return;
        ++cnt;
        // if not finished with desired number of iterations,
        // schedule the next iteration
        if (cnt < numTimes) {
            setTimeout(next, delay);
        }
    }
    // start first iteration
    next();

}
So, to execute your console statement, you'd do this:

runIteration(function(i) {
    console.log(i);
}, 10, 1000);
Working demo: http://jsfiddle.net/jfriend00/HqCZ3/

This could also be extended with a 2nd callback function that was called when the iteration was complete (useful in some circumstances) or it could return a promise that is resolved when the iterations are complete.

Here's what a version that returns a promise would look like: http://jsfiddle.net/jfriend00/XtJ69/

// utility function to call a callback numTimes, 
// separated by delay milliseconds
function runIteration(fn, numTimes, delay) {
    var d = $.Deferred();
    var cnt = 0;

    function end() {
        d.resolve();
    }

    function next() {
        // call the callback and stop iterating if
        // it returns false
        if (fn(cnt) === false) {
            end();
            return;
        }
        ++cnt;
        // if not finished with desired number of iterations,
        // schedule the next iteration
        if (cnt < numTimes) {
            setTimeout(next, delay);
        } else {
            end();
        }
    }
    // start first iteration
    next();
    return d.promise();
}


runIteration(function(i) {
    log(i);
}, 10, 1000).done(function() {
    log("done");
});
*/
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	</script>
</body>
</html>